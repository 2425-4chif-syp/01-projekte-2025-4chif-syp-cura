substitutions:
  name: "cura-display"
  friendly_name: "CURA Medication Display"

esphome:
  name: ${name}
  friendly_name: ${friendly_name}

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG

# WiFi configuration
wifi:
  ssid: !secret ssid
  password: !secret wifi_password
  
  # Fallback hotspot if WiFi connection fails
  ap:
    ssid: "${friendly_name} Fallback"
    password: "cura12345"

# Enable Home Assistant API (optional)
api:
  encryption:
    key: !secret api_encryption_key

# OTA updates
ota:
  password: !secret ota_password

# Web Server (optional - für Debugging)
web_server:
  port: 80

# MQTT Connection zu deinem Server
mqtt:
  broker: vm12.htl-leonding.ac.at
  port: 1883
  username: !secret mqtt_username  # optional, wenn du Authentication aktivierst
  password: !secret mqtt_password  # optional
  client_id: ${name}
  
  # Beim Verbinden Subscribe zu Display-Topic
  on_connect:
    - logger.log: "MQTT Connected - Subscribing to topics"
    - mqtt.subscribe: display/message
    - mqtt.subscribe: display/reminder
  
  # Verbindungsstatus loggen
  on_disconnect:
    - logger.log: "MQTT Disconnected"

# Display Configuration (Beispiel für SSD1306 OLED - anpassen für dein Display)
# Für andere Displays siehe: https://esphome.io/components/display/index.html

# I2C Bus für OLED Display
i2c:
  sda: GPIO21
  scl: GPIO22
  scan: true
  id: i2c_bus

# OLED Display (SSD1306 128x64)
# Falls du ein anderes Display hast, ändere dies entsprechend
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    id: my_display
    update_interval: 1s
    
    lambda: |-
      // Header
      it.rectangle(0, 0, 128, 12);
      it.print(64, 2, id(header_font), TextAlign::TOP_CENTER, "CURA Medikamente");
      
      // Aktuelle Zeit
      it.strftime(64, 16, id(time_font), TextAlign::TOP_CENTER, "%H:%M", id(ntp_time).now());
      
      // Nachricht vom Backend anzeigen
      if (id(display_message).state != "") {
        it.print(2, 30, id(message_font), id(display_message).state.c_str());
      } else {
        it.print(64, 35, id(message_font), TextAlign::TOP_CENTER, "Keine Erinnerung");
      }
      
      // Status-Indikator
      if (id(mqtt_connected)) {
        it.filled_circle(120, 60, 3);  // Grüner Punkt = MQTT verbunden
      }

# Fonts
font:
  - file: "fonts/Roboto-Regular.ttf"
    id: header_font
    size: 10
  
  - file: "fonts/Roboto-Bold.ttf"
    id: time_font
    size: 14
  
  - file: "fonts/Roboto-Regular.ttf"
    id: message_font
    size: 11

# NTP Time für Uhrzeit-Anzeige
time:
  - platform: sntp
    id: ntp_time
    timezone: Europe/Vienna
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org

# Text Sensor für Display-Nachrichten vom Backend
text_sensor:
  - platform: mqtt_subscribe
    name: "Display Message"
    id: display_message
    topic: display/message
    on_value:
      then:
        - logger.log:
            format: "Neue Nachricht empfangen: %s"
            args: [ 'x.c_str()' ]
        # Optional: Buzzer/LED aktivieren bei neuer Nachricht
        - script.execute: notification_alert

  - platform: mqtt_subscribe
    name: "Reminder Info"
    id: reminder_info
    topic: display/reminder
    on_value:
      then:
        - logger.log:
            format: "Erinnerung: %s"
            args: [ 'x.c_str()' ]

  # WiFi Info
  - platform: wifi_info
    ip_address:
      name: "IP Address"
    ssid:
      name: "Connected SSID"

# Binary Sensor für MQTT Connection Status
binary_sensor:
  - platform: mqtt_subscribe
    name: "MQTT Connected"
    id: mqtt_connected
    topic: ${name}/status
    internal: true

# Optional: Buzzer für Benachrichtigungen
output:
  - platform: ledc
    pin: GPIO26
    id: buzzer_output

# Optional: LED für visuelle Benachrichtigung
light:
  - platform: binary
    name: "Notification LED"
    id: notification_led
    output: led_output

output:
  - platform: gpio
    pin: GPIO25
    id: led_output

# Script für Benachrichtigungs-Alert
script:
  - id: notification_alert
    then:
      # LED blinken
      - light.turn_on: notification_led
      - delay: 500ms
      - light.turn_off: notification_led
      - delay: 500ms
      - light.turn_on: notification_led
      - delay: 500ms
      - light.turn_off: notification_led
      
      # Optional: Buzzer piepen (auskommentiert)
      # - output.turn_on: buzzer_output
      # - delay: 200ms
      # - output.turn_off: buzzer_output
      # - delay: 100ms
      # - output.turn_on: buzzer_output
      # - delay: 200ms
      # - output.turn_off: buzzer_output

# Button zum Bestätigen/Stummschalten der Benachrichtigung
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO4
      mode:
        input: true
        pullup: true
    name: "Acknowledge Button"
    id: ack_button
    on_press:
      then:
        - logger.log: "Benachrichtigung bestätigt"
        - mqtt.publish:
            topic: display/acknowledged
            payload: "true"
        - text_sensor.template.publish:
            id: display_message
            state: ""
        - light.turn_off: notification_led
